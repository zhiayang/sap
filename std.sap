# std.sap

namespace builtin
{
	fn to_string(pos: &Position) -> string
	{
		return f"\{xy: ({pos!.x}, {pos!.y}), page: {pos!.page}\}";
	}
}

namespace std
{
	fn style(s: builtin::Style, obj: Block) -> Block { return builtin::apply_style(s, *obj); }
	fn style(s: builtin::Style, obj: Inline) -> Inline { return builtin::apply_style(s, *obj); }

	fn centre(blk: Block) -> Block
	{
		return builtin::apply_style(builtin::Style {
			.alignment = builtin::Alignment::Centred,
		}, *blk);
	}

	struct Section
	{
		num: int;
		name: string;
	};

	var g_sections: [Section] = [];

	fn section(name: string) -> void
	{
		let name_tbo = std::style(builtin::Style {
			.font_size = 2em,
		}, builtin::make_line(builtin::make_text(name)));

		let the_section = Section {
			.num = 1 + g_sections.size(),
			.name = name
		};

		let counter_tbo = std::style(builtin::Style {
			.alignment = builtin::Alignment::Left,
		}, builtin::make_line(builtin::make_text(f"{the_section.num}")));

		g_sections += [the_section];

		var tmp = builtin::current_layout_position();
		tmp.y += 2em;
		builtin::set_layout_cursor(*tmp);

		var pos = builtin::output_at_current(*name_tbo);
		pos.x -= 2em;

		builtin::output_at_position(pos, *counter_tbo);
	}

	fn output_table_of_contents()
	{
		if(builtin::state().layout_pass == 1)
		{
			builtin::request_layout();
			return;
		}

		var i = 0;
		while(i < g_sections.size())
		{
			let s = &g_sections[i];
			let str = f"{s!.num}. {s!.name}";

			let item = std::style(builtin::Style {
				.alignment = builtin::Alignment::Left
			}, builtin::make_paragraph(builtin::make_text(str)));

			builtin::output_at_current(*item);
			i += 1;
		}

		# reset the sections, so that they number correctly again.
		g_sections = [];
	}
}

namespace std::paper_size
{
	let A4 = builtin::Size2d { .x = 210mm, .y = 297mm };
}









#/

# testing
\script {
	var foo = 10;
	builtin::println(f"foo = {foo}");

	foo = 20;
	builtin::println(f"foo = {foo + 1}");

	builtin::bold1(69);
	builtin::bold1("420");

	fn foozle(a: int) -> void
	{
		builtin::println(f"a = {a}");

		if(a > 10)
			builtin::println("a > 10");
		else
			builtin::println("a â‰¤ 10");
	}

	foozle(foo);
	foo = 69;
	foozle(foo);

	struct Cactus
	{
		thorns: int = 100;
		juice: int;
	}

	fn kek(c: &Cactus)
	{
		builtin::println(f"thorns = {c!.thorns}");
		builtin::println(f"juice = {c!.juice}");
	}

	var bar = Cactus {
		.juice = 420,
	};

	bar.juice = 69420;
	bar.kek();

	fn tus(c: &mut Cactus)
	{
		c!.juice = 0;
	}

	tus(&mut bar);

	let kekw: (int)->int;

	builtin::print("------\njuice = ");
	builtin::println(bar.juice);
	builtin::println("------");

	Cactus {
		.thorns = 999,
		.juice = 333
	}.kek();

	let p1: &mut int = null;
	let p2: &mut int = p1;
	let p3: &int = p2;


	let asdf: ?Cactus = Cactus {
		.juice = 6969
	};

	builtin::println("------");
	builtin::println(f"juice = {asdf?.juice}");
}



\script {
	fn fib(n: int) -> int
	{
		if(n == 0)
			return 0;
		else if(n <= 2)
			return 1;

		return fib(n - 1) + fib(n - 2);
	}

	builtin::println(f"fib(15) = {fib(15)}");


	let f1: ?int = null;
	let f2: ?int = 10;

	let f3 = f1 ?? f2 ?? 69;

	if(f1?) builtin::println("f1!");
	if(f2?) builtin::println("f2!");

	builtin::println(f"f3 = {f3}");


	fn foozle(n: int) -> int
	{
		if(n < 0)
			return 69;
		else
			return 420;
	}

	builtin::println(f"hello {10mm} world");
}
/#
