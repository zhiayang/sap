# std.sap

namespace builtin
{
	fn to_string(sz: &Size2d) -> string
	{
		return f"(x: {sz!.x}, y: {sz!.y})";
	}

	fn to_string(pos: &Position) -> string
	{
		return f"\{xy: ({pos!.x}, {pos!.y}), page: {pos!.page}\}";
	}

	fn to_string(pos: &AbsPosition) -> string
	{
		return f"\{xy: ({pos!.x}, {pos!.y}), page: {pos!.page}\}";
	}
}

namespace std
{
	fn centre(blk: Block) -> Block
	{
		return (*blk).apply_style({
			alignment: .Centred,
		});
	}

	struct SubSubSection
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;
	};

	struct SubSection
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;

		subsubsections: [SubSubSection];
	};

	struct Section
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;

		subsections: [SubSection];
	};


	global var g_sections: [Section] = [];
	@layout {
		g_sections = [];
	}

	global let g_sans_font = builtin::find_font_family([
		"Myriad Pro", "sans-serif"
	]);

	global let g_mono_font = builtin::find_font_family([
		"Fantasque Sans Mono", "Menlo", "monospace"
	]);

	fn section(name: string) -> ?Block
	{
		let section_num = 1 + g_sections.size();

		var num_line = builtin::make_hbox(builtin::make_line(builtin::make_text(f"{section_num}")), builtin::hspace(3mm))
			.apply_style({
				alignment: .Right,
				font_size: 13pt,
			});
		num_line.set_width(14mm);

		var name_line = builtin::make_line(builtin::make_text(name)).apply_style({
			font_size: 2em,
		});

		let the_section = Section {
			num: section_num,
			name: name,
			page_num: 0,
			num_tbo_ref: num_line.ref(),
			subsections: [],
		};

		var box = builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em),
		).apply_style({
			font_family: g_sans_font,
		});

		box.offset_position({ x: -14mm, y: 0mm });
		g_sections += [the_section];

		return box;
	}


	fn subsection(name: string) -> ?Block
	{
		if(g_sections.size() == 0)
		{
			builtin::println(f"no sections to put subsection in!");
			return null;
		}

		var sec = &mut g_sections[g_sections.size() - 1];
		let subnum = 1 + sec!.subsections.size();

		var num_line = builtin::make_hbox(builtin::make_line(builtin::make_text(f"{sec!.num}.{subnum}")), builtin::hspace(3mm))
			.apply_style({
				alignment: .Right,
				font_size: 13pt,
			});
		num_line.set_width(14mm);

		var name_line = builtin::make_line(builtin::make_text(name)).apply_style({
			font_size: 1.6em,
		});

		let the_sub = SubSection {
			num: subnum,
			name: name,
			page_num: 0,
			num_tbo_ref: num_line.ref(),
			subsubsections: [],
		};

		var box = builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em),
		).apply_style({
			font_family: g_sans_font,
		});

		box.offset_position({ x: -14mm, y: 0mm });
		sec!.subsections += [the_sub];
		return box;
	}


	fn subsubsection(name: string) -> ?Block
	{
		if(g_sections.size() == 0)
		{
			builtin::println(f"no sections to put subsubsection in!");
			return null;
		}

		var sec = &mut g_sections[g_sections.size() - 1];
		if(sec!.subsections.size() == 0)
		{
			builtin::println(f"no subsections to put subsubsection in!");
			return null;
		}

		var subsec = &mut sec!.subsections[sec!.subsections.size() - 1];
		var subsubnum = 1 + subsec!.subsubsections.size();

		var num_line = builtin::make_hbox(builtin::make_line(builtin::make_text(f"{sec!.num}.{subsec!.num}.{subsubnum}")),
			builtin::hspace(3mm)).apply_style({
				alignment: .Right,
				font_size: 13pt,
			});
		num_line.set_width(14mm);

		var name_line = builtin::make_line(builtin::make_text(name)).apply_style({
			font_size: 1.4em,
		});

		let the_subsub = SubSubSection {
			num: subsubnum,
			name: name,
			page_num: 0,
			num_tbo_ref: num_line.ref(),
		};

		var box = builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em)
		).apply_style({
			font_family: g_sans_font,
		});

		box.offset_position({ x: -14mm, y: 0mm });
		subsec!.subsubsections += [the_subsub];
		return box;
	}




	struct RefRecord
	{
		name: string;
		text: string;

		used: bool = false;
		refnum: ?int = null;
	}

	struct Reference
	{
		num: int;
		record: &mut RefRecord;
	}

	global var g_ref_records: [RefRecord] = [];

	fn install_references(records: [RefRecord])
	{
		if(builtin::state().layout_pass == 1)
			g_ref_records = *records;
	}

	global var g_references: [Reference] = [];
	global var g_citation_num = 0;

	@layout {
		g_references = [];
		g_citation_num = 0;
	}

	fn cite(name: string, page: ?int = null) -> Inline
	{
		# look for an existing ref
		var record: &mut RefRecord = null;

		var i = 0;
		while(i < g_ref_records.size())
		{
			if(g_ref_records[i].name == name)
			{
				record = &mut g_ref_records[i];
				break;
			}

			i += 1;
		}

		if(record == null)
			return builtin::make_text(f"[??????]");

		if(not record!.refnum?)
		{
			record!.refnum = 1 + g_citation_num;
			g_citation_num += 1;
		}

		record!.used = true;

		if(page?)
			return builtin::make_text(f"[{record!.refnum}, p. {page!}]");
		else
			return builtin::make_text(f"[{record!.refnum}]");
	}





	# page numbers
	struct PageNumberState
	{
		ref: BlockRef;
		enable: bool;
		reset: bool;
	}

	global var g_page_numbering_resets: [PageNumberState] = [];
	@layout {
		g_page_numbering_resets = [];
	}

	fn disable_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			ref: x.ref(),
			enable: false,
			reset: false,
		}];

		return x;
	}

	fn enable_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			ref: x.ref(),
			enable: true,
			reset: false,
		}];

		return x;
	}

	fn reset_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			ref: x.ref(),
			enable: true,
			reset: true,
		}];

		return x;
	}

	# actually put the page numbers onto the page
	@finalise {
		var i = 0;
		var rst_idx = 0;
		var enabled = true;

		var page_num_offset = 0;

		var page_num_pos = builtin::document()!.page_size;
		page_num_pos.x -= 34mm;
		page_num_pos.y -= 30mm;

		while(i < builtin::document()!.page_count)
		{
			if(rst_idx < g_page_numbering_resets.size())
			{
				let rst = g_page_numbering_resets[rst_idx];
				let tmp = rst.ref.layout_object()!.position().page;
				if(tmp == i)
				{
					rst_idx += 1;

					enabled = rst.enable;
					if(rst.reset)
						page_num_offset = tmp;
				}
			}

			let page_num = i + 1 - page_num_offset;
			if(enabled)
			{
				let item = builtin::make_line(builtin::make_text(f"{page_num}")).apply_style({
					alignment: .Right,
					font_size: 11pt,
				});

				builtin::output_at_absolute({
					page: i,
					x: page_num_pos.x,
					y: page_num_pos.y,
				}, *item);
			}

			i += 1;
		}
	}

	# generate outline items
	@finalise {
		var i = 0;
		while(i < g_sections.size())
		{
			let s = &mut g_sections[i];
			let pos = s!.num_tbo_ref.layout_object()!.position();

			var children1: [builtin::OutlineItem] = [];

			var si = 0;
			while(si < s!.subsections.size())
			{
				let ss = &mut s!.subsections[si];
				let pos = ss!.num_tbo_ref.layout_object()!.position();

				var children2: [builtin::OutlineItem] = [];

				var ssi = 0;
				while(ssi < ss!.subsubsections.size())
				{
					let sss = &mut ss!.subsubsections[ssi];
					let pos = sss!.num_tbo_ref.layout_object()!.position();

					children2 += [builtin::OutlineItem {
						title: sss!.name,
						position: pos,
						children: [],
					}];

					ssi += 1;
				}

				children1 += [builtin::OutlineItem {
					title: ss!.name,
					position: pos,
					children: *children2,
				}];

				si += 1;
			}

			builtin::document()!.outline_items += [builtin::OutlineItem {
				title: s!.name,
				position: pos,
				children: *children1,
			}];

			i += 1;
		}
	}





	@post {

		var i = 0;
		var rst_idx = 0;
		var page_offset = 0;

		while(i < g_sections.size())
		{
			let s = &mut g_sections[i];
			let tmp = s!.num_tbo_ref.layout_object()!.position();

			while(rst_idx < g_page_numbering_resets.size())
			{
				let rst = g_page_numbering_resets[rst_idx];
				let p = rst.ref.layout_object()!.position().page;

				if(tmp.page >= p)
				{
					rst_idx += 1;
					if(rst.reset)
						page_offset += p;
				}
				else
				{
					break;
				}
			}

			g_sections[i].page_num = 1 + tmp.page - page_offset;

			var si = 0;
			while(si < s!.subsections.size())
			{
				let ss = &mut s!.subsections[si];
				let tmp = ss!.num_tbo_ref.layout_object()!.position();

				while(rst_idx < g_page_numbering_resets.size())
				{
					let rst = g_page_numbering_resets[rst_idx];
					let p = rst.ref.layout_object()!.position().page;

					if(tmp.page >= p)
					{
						rst_idx += 1;
						if(rst.reset)
							page_offset += p;
					}
					else
					{
						break;
					}
				}

				ss!.page_num = 1 + tmp.page - page_offset;

				var ssi = 0;
				while(ssi < ss!.subsubsections.size())
				{
					let sss = &mut ss!.subsubsections[ssi];
					let tmp = sss!.num_tbo_ref.layout_object()!.position();

					while(rst_idx < g_page_numbering_resets.size())
					{
						let rst = g_page_numbering_resets[rst_idx];
						let p = rst.ref.layout_object()!.position().page;

						if(tmp.page >= p)
						{
							rst_idx += 1;
							if(rst.reset)
								page_offset += p;
						}
						else
						{
							break;
						}
					}

					sss!.page_num = 1 + tmp.page - page_offset;
					ssi += 1;
				}

				si += 1;
			}

			i += 1;
		}
	}



	global var g_saved_sections: [Section] = [];
	@post {
		g_saved_sections = g_sections;
	}

	fn output_table_of_contents() -> ?Block
	{
		if(builtin::state().layout_pass == 1)
		{
			builtin::request_layout();
			return null;
		}

		var lines = [:Block];

		var i = 0;
		while(i < g_saved_sections.size())
		{
			let s = &g_saved_sections[i];

			let number = builtin::make_line(builtin::bold1(builtin::make_text(f"{s!.num}.")));
			number.set_width(8mm);

			let title = builtin::make_line(builtin::bold1(builtin::make_text(s!.name)));
			let heading = builtin::make_hbox(
				*number, *title
			);

			let pagenum = builtin::make_hbox(
				builtin::make_line(builtin::bold1(builtin::make_text(f"{s!.page_num}")))
			);

			let item = builtin::make_hbox(
				*heading, *pagenum
			).apply_style({
				alignment: .Justified
			});

			if(i != 0)
				lines += [builtin::vspace(0.7em)];

			lines += [*item];

			var si = 0;
			while(si < s!.subsections.size())
			{
				let ss = &s!.subsections[si];

				let number = builtin::make_line(builtin::make_text(f"{s!.num}.{ss!.num}"));
				number.set_width(11mm);

				let title = builtin::make_line(builtin::make_text(ss!.name));
				let heading = builtin::make_hbox(
					builtin::hspace(9mm), *number, *title
				);

				let pagenum = builtin::make_hbox(
					builtin::make_line(builtin::make_text(f"{ss!.page_num}"))
				);

				let item = builtin::make_hbox(
					*heading, *pagenum
				).apply_style({
					alignment: .Justified
				});

				lines += [*item];

				var ssi = 0;
				while(ssi < ss!.subsubsections.size())
				{
					let sss = &ss!.subsubsections[ssi];

					let number = builtin::make_line(builtin::make_text(f"{s!.num}.{ss!.num}.{sss!.num}"));
					number.set_width(15mm);

					let title = builtin::make_line(builtin::make_text(sss!.name));
					let heading = builtin::make_hbox(
						builtin::hspace(20mm), *number, *title
					);

					let pagenum = builtin::make_hbox(
						builtin::make_line(builtin::make_text(f"{sss!.page_num}"))
					);

					let item = builtin::make_hbox(
						*heading, *pagenum
					).apply_style({
						alignment: .Justified
					});

					lines += [*item];
					ssi += 1;
				}

				si += 1;
			}

			i += 1;
		}

		var ret = builtin::make_vbox(...*lines).apply_style({
			paragraph_spacing: 0em,
		});

		ret = builtin::make_vbox(
			builtin::make_hbox(
				builtin::make_line(builtin::make_text("Contents"))
			).apply_style({ alignment: .Left, font_size: 20pt, font_family: g_sans_font }),
			*ret
		);

		# we must re-request layout again, to make the page numbers correct.
		if(builtin::state().layout_pass == 2)
			builtin::request_layout();

		return ret;
	}



	fn output_list_of_references() -> ?Block
	{
		# sort... the record list
		var records: [RefRecord] = [];

		var next = 1;
		while(true)
		{
			var found = false;
			var i = 0;
			while(i < g_ref_records.size())
			{
				if(not g_ref_records[i].used || not g_ref_records[i].refnum?)
				{
					i += 1;
					continue;
				}

				if(g_ref_records[i].refnum! == next)
				{
					records += [g_ref_records[i]];
					found = true;
					next += 1;
					break;
				}

				i += 1;
			}

			if(not found)
				break;
		}

		var lines = [:Block];

		var i = 0;
		while(i < records.size())
		{
			let rec = *records[i];

			let number = builtin::make_hbox(builtin::make_line(builtin::make_text(f"[{rec.refnum!}]"))).apply_style({
				alignment: .Right,
			});

			number.set_width(10mm);

			let item = builtin::make_hbox(
				*number,
				builtin::hspace(1em),
				builtin::make_paragraph(builtin::make_text(rec.text)).apply_style({
					line_spacing: 1.1,
					alignment: .Justified
				})
			).apply_style({
				alignment: .Left
			});

			lines += [*item];
			i += 1;
		}

		return builtin::make_vbox(builtin::make_hbox(
				builtin::make_line(builtin::make_text("References"))
			).apply_style({alignment: .Left, font_size: 20pt, font_family: g_sans_font}),
			...*lines
		);
	}















	fn numbered_list(items: [string...]) -> ?Block
	{
		var lines = [:Block];
		var i = 0;
		while(i < items.size())
		{
			lines += [builtin::make_hbox(
				builtin::hspace(0.8em),
				builtin::make_line(builtin::make_text(f"{i + 1}.")).apply_style({ alignment: .Right }),
				builtin::hspace(0.6em),
				builtin::make_line(builtin::make_text(items[i]))
			)];
			i += 1;
		}

		return builtin::make_vbox(builtin::vspace(-0.5em), ...*lines)
			.apply_style({ paragraph_spacing: 0.0em, });
	}

	fn bulleted_list(items: [Inline...]) -> Block
	{
		var lines = [:Block];
		var i = 0;
		while(i < items.size())
		{
			lines += [builtin::make_hbox(
				builtin::hspace(0.8em),
				builtin::make_line(builtin::make_text(f"•")).apply_style({ alignment: .Right }),
				builtin::hspace(0.6em),
				builtin::make_line(*items[i])
			)];
			i += 1;
		}

		return builtin::make_vbox(builtin::vspace(-0.5em), ...*lines)
			.apply_style({ paragraph_spacing: 0.0em, });
	}

	fn bulleted_list(items: [string...]) -> Block
	{
		var inlines = [:Inline];
		var i = 0;
		while(i < items.size())
		{
			inlines += [builtin::make_text(items[i])];
			i += 1;
		}

		return bulleted_list(...*inlines);
	}





	fn emph(x: string) -> Inline
	{
		return builtin::italic1(builtin::make_text(x));
	}

	fn emph(x: Inline) -> Inline
	{
		return builtin::italic1(*x);
	}

	fn quote(x: string) -> Inline
	{
		return builtin::make_text(f"‘{x}’");
	}

	fn mono(x: string) -> Inline
	{
		return builtin::make_text(x).apply_style({
			font_family: g_mono_font
		});
	}


	enum Prefix
	{
		nano;
		micro;
		milli;
		none;
		kilo;
		mega;
		giga;
	}

	enum Unit
	{
		byte;
		second;
	}

	fn _get_prefix_and_units(prefix: ?Prefix = null, unit: ?Unit = null,
		p: &mut string, u: &mut string)
	{
		if(prefix?)
		{
			if(prefix! == Prefix::nano)         p! = "n";
			else if(prefix! == Prefix::micro)   p! = "µ";
			else if(prefix! == Prefix::milli)   p! = "m";
			else if(prefix! == Prefix::kilo)    p! = "k";
			else if(prefix! == Prefix::mega)    p! = "M";
			else if(prefix! == Prefix::giga)    p! = "G";
		}

		if(unit?)
		{
			if(unit! == Unit::byte)         u! = "B";
			else if(unit! == Unit::second)  u! = "s";
		}
	}

	fn qty(num: int, prefix: ?Prefix = null, unit: ?Unit = null) -> Inline
	{
		var p = "";
		var u = "";
		_get_prefix_and_units(prefix, unit, &mut p, &mut u);

		return builtin::make_text(f"{num} {p}{u}");
	}

	fn qty(num: float, prefix: ?Prefix = null, unit: ?Unit = null) -> Inline
	{
		var p = "";
		var u = "";
		_get_prefix_and_units(prefix, unit, &mut p, &mut u);

		return builtin::make_text(f"{num} {p}{u}");
	}
}

namespace std::paper_size
{
	global let A4 = builtin::Size2d { x: 210mm, y: 297mm };
}
