# std.sap

namespace builtin
{
	fn to_string(pos: &Position) -> string
	{
		return f"\{xy: ({pos!.x}, {pos!.y}), page: {pos!.page}\}";
	}

	fn to_string(pos: &AbsPosition) -> string
	{
		return f"\{xy: ({pos!.x}, {pos!.y}), page: {pos!.page}\}";
	}
}

namespace std
{
	fn style(s: builtin::Style, obj: Block) -> Block { return builtin::apply_style(s, *obj); }
	fn style(s: builtin::Style, obj: Inline) -> Inline { return builtin::apply_style(s, *obj); }

	fn centre(blk: Block) -> Block
	{
		return builtin::apply_style({
			.alignment = .Centred,
		}, *blk);
	}

	struct SubSubSection
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;
	};

	struct SubSection
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;

		subsubsections: [SubSubSection];
	};

	struct Section
	{
		num: int;
		name: string;
		page_num: int;
		num_tbo_ref: BlockRef;

		subsections: [SubSection];
	};


	global var g_sections: [Section] = [];
	@layout {
		g_sections = [];
	}

	global let g_sans_font = builtin::find_font_family([
		"Myriad Pro", "sans-serif"
	]);

	global let g_mono_font = builtin::find_font_family([
		"Fantasque Sans Mono", "Menlo", "monospace"
	]);

	fn section(name: string) -> ?Block
	{
		let section_num = 1 + g_sections.size();

		var num_line = builtin::apply_style({
			.alignment = .Right,
			.font_size = 13pt,
		}, builtin::make_hbox(builtin::make_line(builtin::make_text(f"{section_num}")), builtin::hspace(3mm)));
		num_line.set_width(14mm);

		var name_line = builtin::apply_style({
			.font_size = 2em,
		}, builtin::make_line(builtin::make_text(name)));

		let the_section = Section {
			.num = section_num,
			.name = name,
			.page_num = 0,
			.num_tbo_ref = num_line.ref(),
			.subsections = [],
		};

		var box = builtin::apply_style({
			.font_family = g_sans_font,
		}, builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em),
		));

		box.offset_position({ .x = -14mm, .y = 0mm });
		g_sections += [the_section];

		return box;
	}


	fn subsection(name: string) -> ?Block
	{
		if(g_sections.size() == 0)
		{
			builtin::println(f"no sections to put subsection in!");
			return null;
		}

		var sec = &mut g_sections[g_sections.size() - 1];
		let subnum = 1 + sec!.subsections.size();

		var num_line = builtin::apply_style({
			.alignment = .Right,
			.font_size = 13pt,
		}, builtin::make_hbox(builtin::make_line(builtin::make_text(f"{sec!.num}.{subnum}")), builtin::hspace(3mm)));
		num_line.set_width(14mm);

		var name_line = builtin::apply_style({
			.font_size = 1.6em,
		}, builtin::make_line(builtin::make_text(name)));

		let the_sub = SubSection {
			.num = subnum,
			.name = name,
			.page_num = 0,
			.num_tbo_ref = num_line.ref(),
			.subsubsections = [],
		};

		var box = builtin::apply_style({
			.font_family = g_sans_font,
		}, builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em)
		));

		box.offset_position({ .x = -14mm, .y = 0mm });
		sec!.subsections += [the_sub];
		return box;
	}


	fn subsubsection(name: string) -> ?Block
	{
		if(g_sections.size() == 0)
		{
			builtin::println(f"no sections to put subsubsection in!");
			return null;
		}

		var sec = &mut g_sections[g_sections.size() - 1];
		if(sec!.subsections.size() == 0)
		{
			builtin::println(f"no subsections to put subsubsection in!");
			return null;
		}

		var subsec = &mut sec!.subsections[sec!.subsections.size() - 1];
		var subsubnum = 1 + subsec!.subsubsections.size();

		var num_line = builtin::apply_style({
			.alignment = .Right,
			.font_size = 13pt,
		}, builtin::make_hbox(builtin::make_line(builtin::make_text(f"{sec!.num}.{subsec!.num}.{subsubnum}")), builtin::hspace(3mm)));
		num_line.set_width(14mm);

		var name_line = builtin::apply_style({
			.font_size = 1.4em,
		}, builtin::make_line(builtin::make_text(name)));

		let the_subsub = SubSubSection {
			.num = subsubnum,
			.name = name,
			.page_num = 0,
			.num_tbo_ref = num_line.ref(),
		};

		var box = builtin::apply_style({
			.font_family = g_sans_font,
		}, builtin::make_vbox(
			builtin::vspace(0.5em),
			builtin::make_hbox(*num_line, *name_line),
			builtin::vspace(-0.9em)
		));

		box.offset_position({ .x = -14mm, .y = 0mm });
		subsec!.subsubsections += [the_subsub];
		return box;
	}




	struct RefRecord
	{
		name: string;
		text: string;

		used: bool = false;
		refnum: ?int = null;
	}

	struct Reference
	{
		num: int;
		record: &mut RefRecord;
	}

	global var g_ref_records: [RefRecord] = [];

	fn install_references(records: [RefRecord])
	{
		if(builtin::state().layout_pass == 1)
			g_ref_records = *records;
	}

	global var g_references: [Reference] = [];
	global var g_citation_num = 0;

	@layout {
		g_references = [];
		g_citation_num = 0;
	}

	fn cite(name: string, page: ?int = null) -> Inline
	{
		# look for an existing ref
		var record: &mut RefRecord = null;

		var i = 0;
		while(i < g_ref_records.size())
		{
			if(g_ref_records[i].name == name)
			{
				record = &mut g_ref_records[i];
				break;
			}

			i += 1;
		}

		if(record == null)
			return builtin::make_text(f"[??????]");

		if(not record!.refnum?)
		{
			record!.refnum = 1 + g_citation_num;
			g_citation_num += 1;
		}

		record!.used = true;

		if(page?)
			return builtin::make_text(f"[{record!.refnum}, p. {page!}]");
		else
			return builtin::make_text(f"[{record!.refnum}]");
	}





	# page numbers
	struct PageNumberState
	{
		ref: BlockRef;
		enable: bool;
		reset: bool;
	}

	global var g_page_numbering_resets: [PageNumberState] = [];
	@layout {
		g_page_numbering_resets = [];
	}

	fn disable_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			.ref = x.ref(),
			.enable = false,
			.reset = false,
		}];

		return x;
	}

	fn enable_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			.ref = x.ref(),
			.enable = true,
			.reset = false,
		}];

		return x;
	}

	fn reset_page_numbering() -> Block
	{
		# FIXME: this feels kinda hackish.
		let x = builtin::vspace(0em);
		g_page_numbering_resets += [PageNumberState {
			.ref = x.ref(),
			.enable = true,
			.reset = true,
		}];

		return x;
	}

	@finalise {
		var i = 0;
		var rst_idx = 0;
		var enabled = true;

		var page_num_pos = builtin::state().page_size;
		page_num_pos.x -= 34mm;
		page_num_pos.y -= 30mm;

		while(i < builtin::state().page_count)
		{
			var page_num = i + 1;
			if(rst_idx < g_page_numbering_resets.size())
			{
				let rst = g_page_numbering_resets[rst_idx];
				let tmp = rst.ref.layout_object()!.position().page;
				if(tmp == i)
				{
					rst_idx += 1;

					enabled = rst.enable;
					if(rst.reset)
						page_num = 1;
				}
			}

			if(enabled)
			{
				let item = std::style({
					.alignment = .Right,
					.font_size = 11pt,
				}, builtin::make_line(builtin::make_text(f"{page_num}")));

				builtin::output_at_absolute({
					.page = i,
					.x = page_num_pos.x,
					.y = page_num_pos.y,
				}, *item);
			}

			i += 1;
		}
	}


	@post {

		var i = 0;
		var rst_idx = 0;
		var page_offset = 0;

		while(i < g_sections.size())
		{
			let s = &mut g_sections[i];
			let tmp = s!.num_tbo_ref.layout_object()!.position();

			while(rst_idx < g_page_numbering_resets.size())
			{
				let rst = g_page_numbering_resets[rst_idx];
				let p = rst.ref.layout_object()!.position().page;

				if(tmp.page >= p)
				{
					rst_idx += 1;
					if(rst.reset)
						page_offset += p;
				}
				else
				{
					break;
				}
			}

			g_sections[i].page_num = 1 + tmp.page - page_offset;

			var si = 0;
			while(si < s!.subsections.size())
			{
				let ss = &mut s!.subsections[si];
				let tmp = ss!.num_tbo_ref.layout_object()!.position();

				while(rst_idx < g_page_numbering_resets.size())
				{
					let rst = g_page_numbering_resets[rst_idx];
					let p = rst.ref.layout_object()!.position().page;

					if(tmp.page >= p)
					{
						rst_idx += 1;
						if(rst.reset)
							page_offset += p;
					}
					else
					{
						break;
					}
				}

				ss!.page_num = 1 + tmp.page - page_offset;

				var ssi = 0;
				while(ssi < ss!.subsubsections.size())
				{
					let sss = &mut ss!.subsubsections[ssi];
					let tmp = sss!.num_tbo_ref.layout_object()!.position();

					while(rst_idx < g_page_numbering_resets.size())
					{
						let rst = g_page_numbering_resets[rst_idx];
						let p = rst.ref.layout_object()!.position().page;

						if(tmp.page >= p)
						{
							rst_idx += 1;
							if(rst.reset)
								page_offset += p;
						}
						else
						{
							break;
						}
					}

					sss!.page_num = 1 + tmp.page - page_offset;
					ssi += 1;
				}

				si += 1;
			}

			i += 1;
		}
	}



	global var g_saved_sections: [Section] = [];
	@post {
		g_saved_sections = *g_sections;
	}

	fn output_table_of_contents() -> ?Block
	{
		if(builtin::state().layout_pass == 1)
		{
			builtin::request_layout();
			return null;
		}

		var lines = [:Block];

		var i = 0;
		while(i < g_saved_sections.size())
		{
			let s = &g_saved_sections[i];

			let number = builtin::make_line(builtin::bold1(builtin::make_text(f"{s!.num}.")));
			number.set_width(8mm);

			let title = builtin::make_line(builtin::bold1(builtin::make_text(s!.name)));
			let heading = builtin::make_hbox(
				*number, *title
			);

			let pagenum = builtin::make_hbox(
				builtin::make_line(builtin::bold1(builtin::make_text(f"{s!.page_num}")))
			);

			let item = builtin::apply_style({
				.alignment = .Justified
			}, builtin::make_hbox(
				*heading, *pagenum
			));

			if(i != 0)
				lines += [builtin::vspace(0.7em)];

			lines += [*item];

			var si = 0;
			while(si < s!.subsections.size())
			{
				let ss = &s!.subsections[si];

				let number = builtin::make_line(builtin::make_text(f"{s!.num}.{ss!.num}"));
				number.set_width(11mm);

				let title = builtin::make_line(builtin::make_text(ss!.name));
				let heading = builtin::make_hbox(
					builtin::hspace(9mm), *number, *title
				);

				let pagenum = builtin::make_hbox(
					builtin::make_line(builtin::make_text(f"{ss!.page_num}"))
				);

				let item = builtin::apply_style({
					.alignment = .Justified
				}, builtin::make_hbox(
					*heading, *pagenum
				));

				lines += [*item];

				var ssi = 0;
				while(ssi < ss!.subsubsections.size())
				{
					let sss = &ss!.subsubsections[ssi];

					let number = builtin::make_line(builtin::make_text(f"{s!.num}.{ss!.num}.{sss!.num}"));
					number.set_width(15mm);

					let title = builtin::make_line(builtin::make_text(sss!.name));
					let heading = builtin::make_hbox(
						builtin::hspace(20mm), *number, *title
					);

					let pagenum = builtin::make_hbox(
						builtin::make_line(builtin::make_text(f"{sss!.page_num}"))
					);

					let item = builtin::apply_style({
						.alignment = .Justified
					}, builtin::make_hbox(
						*heading, *pagenum
					));

					lines += [*item];
					ssi += 1;
				}

				si += 1;
			}

			i += 1;
		}

		var ret = builtin::make_vbox((*lines)...);
		ret = builtin::apply_style({
			.paragraph_spacing = 0em,
		}, *ret);

		ret = builtin::make_vbox(
			builtin::apply_style({ .alignment = .Centred, .font_size = 28pt, .font_family = g_sans_font }, builtin::make_hbox(
				builtin::make_line(builtin::make_text("Contents"))
			)),
			*ret
		);

		# we must re-request layout again, to make the page numbers correct.
		if(builtin::state().layout_pass == 2)
			builtin::request_layout();

		return ret;
	}



	fn output_list_of_references() -> ?Block
	{
		# sort... the record list
		var records: [RefRecord] = [];

		var next = 1;
		while(true)
		{
			var found = false;
			var i = 0;
			while(i < g_ref_records.size())
			{
				if(not g_ref_records[i].used || not g_ref_records[i].refnum?)
				{
					i += 1;
					continue;
				}

				if(g_ref_records[i].refnum! == next)
				{
					records += [g_ref_records[i]];
					found = true;
					next += 1;
					break;
				}

				i += 1;
			}

			if(not found)
				break;
		}

		var lines = [:Block];

		var i = 0;
		while(i < records.size())
		{
			let rec = *records[i];

			let number = builtin::apply_style({
				.alignment = .Right,
			}, builtin::make_hbox(builtin::make_line(builtin::make_text(f"[{rec.refnum!}]"))));

			number.set_width(10mm);

			let item = builtin::apply_style({
				.alignment = .Left
			}, builtin::make_hbox(
				*number, builtin::hspace(1em), builtin::apply_style({
					.line_spacing = 1.1,
					.alignment = .Justified
				}, builtin::make_paragraph(builtin::make_text(rec.text)))
			));

			lines += [*item];
			i += 1;
		}

		return builtin::make_vbox(builtin::apply_style({
				.alignment = .Left, .font_size = 24pt, .font_family = g_sans_font
			}, builtin::make_hbox(
				builtin::make_line(builtin::make_text("References"))
			)),
			(*lines)...
		);
	}















	fn numbered_list(items: [string...]) -> ?Block
	{
		var lines = [:Block];
		var i = 0;
		while(i < items.size())
		{
			lines += [builtin::make_hbox(
				builtin::hspace(0.8em),
				builtin::apply_style({ .alignment = .Right },
					builtin::make_line(builtin::make_text(f"{i + 1}."))
				),
				builtin::hspace(0.6em),
				builtin::make_line(builtin::make_text(items[i]))
			)];
			i += 1;
		}

		return builtin::apply_style({ .paragraph_spacing = 0.0em, },
			builtin::make_vbox(builtin::vspace(-0.5em), (*lines)...)
		);
	}

	fn bulleted_list(items: [Inline...]) -> Block
	{
		var lines = [:Block];
		var i = 0;
		while(i < items.size())
		{
			lines += [builtin::make_hbox(
				builtin::hspace(0.8em),
				builtin::apply_style({ .alignment = .Right },
					builtin::make_line(builtin::make_text(f"•"))
				),
				builtin::hspace(0.6em),
				builtin::make_line(*items[i])
			)];
			i += 1;
		}

		return builtin::apply_style({ .paragraph_spacing = 0.0em, },
			builtin::make_vbox(builtin::vspace(-0.5em), (*lines)...)
		);
	}

	fn bulleted_list(items: [string...]) -> Block
	{
		var inlines = [:Inline];
		var i = 0;
		while(i < items.size())
		{
			inlines += [builtin::make_text(items[i])];
			i += 1;
		}

		return bulleted_list((*inlines)...);
	}





	fn emph(x: string) -> Inline
	{
		return builtin::italic1(builtin::make_text(x));
	}

	fn emph(x: Inline) -> Inline
	{
		return builtin::italic1(*x);
	}

	fn quote(x: string) -> Inline
	{
		return builtin::make_text(f"‘{x}’");
	}

	fn mono(x: string) -> Inline
	{
		return builtin::apply_style({
			.font_family = g_mono_font
		}, builtin::make_text(x));
	}


	enum Prefix
	{
		nano;
		micro;
		milli;
		none;
		kilo;
		mega;
		giga;
	}

	enum Unit
	{
		byte;
		second;
	}

	fn _get_prefix_and_units(prefix: ?Prefix = null, unit: ?Unit = null,
		p: &mut string, u: &mut string)
	{
		if(prefix?)
		{
			if(prefix! == Prefix::nano)         p! = "n";
			else if(prefix! == Prefix::micro)   p! = "µ";
			else if(prefix! == Prefix::milli)   p! = "m";
			else if(prefix! == Prefix::kilo)    p! = "k";
			else if(prefix! == Prefix::mega)    p! = "M";
			else if(prefix! == Prefix::giga)    p! = "G";
		}

		if(unit?)
		{
			if(unit! == Unit::byte)         u! = "B";
			else if(unit! == Unit::second)  u! = "s";
		}
	}

	fn qty(num: int, prefix: ?Prefix = null, unit: ?Unit = null) -> Inline
	{
		var p = "";
		var u = "";
		_get_prefix_and_units(prefix, unit, &mut p, &mut u);

		return builtin::make_text(f"{num} {p}{u}");
	}

	fn qty(num: float, prefix: ?Prefix = null, unit: ?Unit = null) -> Inline
	{
		var p = "";
		var u = "";
		_get_prefix_and_units(prefix, unit, &mut p, &mut u);

		return builtin::make_text(f"{num} {p}{u}");
	}
}

namespace std::paper_size
{
	global let A4 = builtin::Size2d { .x = 210mm, .y = 297mm };
}
