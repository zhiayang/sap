%YAML 1.2
---
# http://www.sublimetext.com/docs/syntax.html
version: 2
name: sap
file_extensions:
  - sap
scope: source.sap
contexts:
  # Rule: array-literal
  array-literal|0:
    - match: ':'
      scope: punctuation.colon.sap
      push: array-literal|1
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [array-literal|3, array-literal|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\]'
      scope: punctuation.bracket.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: array-literal
  array-literal|1:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: array-literal|4
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: array-literal|4
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [array-literal|4, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [array-literal|4, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: array-literal|4
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [array-literal|4, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [array-literal|4, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: array-literal
  array-literal|2:
    - match: ','
      scope: punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: array-literal
  array-literal|3:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '\]'
      scope: punctuation.bracket.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: array-literal
  array-literal|4:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [array-literal|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [array-literal|2, binop-expr2|0, unary-expr|0]
    - match: '\]'
      scope: punctuation.bracket.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: binop-expr2
  binop-expr2|0:
    - match: '//\?='
      scope: keyword.operator.binop.struct-update.sap
      push: binop-expr2|1
      pop: true
    - match: '//='
      scope: keyword.operator.binop.struct-update.sap
      push: binop-expr2|1
      pop: true
    - match: '//\?'
      scope: keyword.operator.binop.struct-update.sap
      push: binop-expr2|1
      pop: true
    - match: '//'
      scope: keyword.operator.binop.struct-update.sap
      push: binop-expr2|1
      pop: true
    - match: '\+='
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '-='
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '\*='
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '/='
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '%='
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '<='
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '>='
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '=='
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '!='
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '\?\?'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: 'and'
      scope: keyword.operator.binop.logical.sap
      push: binop-expr2|2
      pop: true
    - match: 'or'
      scope: keyword.operator.binop.logical.sap
      push: binop-expr2|2
      pop: true
    - match: '&&'
      scope: keyword.operator.binop.logical.sap
      push: binop-expr2|2
      pop: true
    - match: '\|\|'
      scope: keyword.operator.binop.logical.sap
      push: binop-expr2|2
      pop: true
    - match: '\+'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '-'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '\*'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '/'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '%'
      scope: keyword.operator.binop.arith.sap
      push: binop-expr2|2
      pop: true
    - match: '<'
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '>'
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '≤'
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '≥'
      scope: keyword.operator.binop.compare.sap
      push: binop-expr2|2
      pop: true
    - match: '='
      scope: keyword.operator.binop.assign.sap
      push: binop-expr2|2
      pop: true
    - match: '(?=;)'
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: binop-expr2
  binop-expr2|1:
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [binop-expr2|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: binop-expr2|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: binop-expr2
  binop-expr2|2:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: binop-expr
  binop-expr|0:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: block-comment
  block-comment|0:
    - meta_content_scope: comment.block.sap
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(?!#/).'
    - match: '(#/)'
      scope: comment.block.sap punctuation.definition.comment.sap
      pop: true
    - match: '(?=\S)'
      push: block-comment|1
      pop: true
  # Rule: block-comment
  block-comment|1:
    - meta_content_scope: comment.block.sap
    - match: '(#/)'
      scope: comment.block.sap punctuation.definition.comment.sap
      pop: true
  # Rule: block-stmt
  block-stmt|0:
    - match: '\s*\{'
      scope: punctuation.brace.block-start.sap
      push: block-stmt|1
      pop: true
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
      pop: true
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
      pop: true
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
      pop: true
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
      pop: true
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
      pop: true
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
      pop: true
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
      pop: true
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
      pop: true
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
      pop: true
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
      pop: true
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
      pop: true
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
      pop: true
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
      pop: true
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
      pop: true
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
      pop: true
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
      pop: true
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
      pop: true
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: block-stmt
  block-stmt|1:
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
      push: block-stmt|0
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: ';'
      scope: punctuation.terminator.sap
    - match: '\}'
      scope: punctuation.brace.block-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: break-stmt
  break-stmt|0:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|0:
    - match: '\('
      scope: punctuation.paren.sap
      push: cast-expr|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|1:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [cast-expr|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [cast-expr|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|2:
    - match: ','
      scope: punctuation.comma.sap
      push: cast-expr|3
      pop: true
    - match: '\)'
      scope: punctuation.paren.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|3:
    - match: '\$'
      scope: support.type.sap
      push: [cast-expr|4, type|0]
      pop: true
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: cast-expr|4
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: cast-expr|4
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [cast-expr|4, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [cast-expr|4, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: cast-expr|4
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [cast-expr|4, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [cast-expr|4, type|3]
      pop: true
    - match: '\.'
      scope: punctuation.period.sap
      push: cast-expr|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|4:
    - match: '\)'
      scope: punctuation.paren.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: cast-expr
  cast-expr|5:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.union-case.sap
      push: cast-expr|4
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: continue-stmt
  continue-stmt|0:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: document-start
  document-start|0:
    - match: '\('
      scope: punctuation.paren.call-start.sap
      push: document-start|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: document-start
  document-start|1:
    - match: '([A-Za-z_][[:word:]]*)\s*(:)\s*(?!:)'
      captures:
        1: variable.parameter.sap
        2: punctuation.colon.sap
      push: [document-start|2, binop-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [document-start|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [document-start|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [document-start|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [document-start|2, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [document-start|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [document-start|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [document-start|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\)'
      scope: punctuation.paren.call-end.sap
      push: document-start|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: document-start
  document-start|2:
    - include: include!document-start@1
    - match: '\)'
      scope: punctuation.paren.call-end.sap
      push: document-start|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: document-start
  document-start|3:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  document-start|4|document-start@1:
    - meta_include_prototype: false
    - match: ','
      scope: punctuation.comma.sap
      push: document-start|5|document-start@1
      pop: true
  # Rule: document-start
  document-start|5|document-start@1:
    - match: '([A-Za-z_][[:word:]]*)\s*(:)\s*(?!:)'
      captures:
        1: variable.parameter.sap
        2: punctuation.colon.sap
      push: binop-expr|0
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      fail: document-start@1
  document-start|6|document-start@1:
    - meta_include_prototype: false
    - match: ','
      scope: punctuation.comma.sap
      push: document-start|7|document-start@1
      pop: true
  # Rule: document-start
  document-start|7|document-start@1:
    - match: '\)'
      scope: punctuation.paren.call-end.sap
      push: document-start|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Meta scope context for else-stmt
  else-stmt|meta:
    - meta_content_scope: meta.control-flow.else-stmt.sap
    - match: ''
      pop: true
  # Rule: enum-defn
  enum-defn|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.enum.sap
      push: enum-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: enum-defn
  enum-defn|1:
    - match: ':'
      scope: punctuation.colon.sap
      push: enum-defn|2
      pop: true
    - match: '\{'
      scope: punctuation.brace.sap
      push: enum-defn|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: enum-defn
  enum-defn|2:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: enum-defn|5
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: enum-defn|5
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [enum-defn|5, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [enum-defn|5, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: enum-defn|5
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [enum-defn|5, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [enum-defn|5, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: enum-defn
  enum-defn|3:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.enum-enumerator.sap
      push: [enum-defn|4, enum-enumerator-defn|0]
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: enum-defn
  enum-defn|4:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: enum-defn
  enum-defn|5:
    - match: '\{'
      scope: punctuation.brace.sap
      push: enum-defn|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: enum-enumerator-defn
  enum-enumerator-defn|0:
    - match: '='
      scope: keyword.operator.sap
      push: binop-expr|0
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: enum-literal
  enum-literal|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.enumerator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|0:
    - match: '\('
      scope: punctuation.paren.while-start.sap
      push: for-loop|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|1:
    - match: 'var|let'
      scope: storage.type.sap
      push: for-loop|2
      pop: true
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|3
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: for-loop|4
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: for-loop|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|10:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\)'
      scope: punctuation.paren.while-end.sap
      push: block-stmt|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|11:
    - match: ':'
      scope: punctuation.colon.sap
      push: for-loop|12
      pop: true
    - match: '='
      scope: keyword.operator.sap
      push: for-loop|13
      pop: true
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|12:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: for-loop|15
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: for-loop|15
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [for-loop|15, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [for-loop|15, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: for-loop|15
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [for-loop|15, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [for-loop|15, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|13:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [for-loop|14, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [for-loop|14, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|14:
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|15:
    - match: '='
      scope: keyword.operator.sap
      push: for-loop|13
      pop: true
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|2:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: for-loop|11
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|3:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [for-loop|9, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [for-loop|9, binop-expr2|0, unary-expr|0]
      pop: true
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|10
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|4:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: for-loop|8
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: for-loop|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|5:
    - match: 'in'
      scope: keyword.in.sap
      push: for-loop|6
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|6:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [for-loop|7, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [for-loop|7, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|7:
    - match: '\)'
      scope: punctuation.paren.while-end.sap
      push: block-stmt|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|8:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: for-loop|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: for-loop
  for-loop|9:
    - match: ';'
      scope: punctuation.semicolon.sap
      push: for-loop|10
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: fstring-contents
  fstring-contents|0:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [fstring-contents|1, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [fstring-contents|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: fstring-contents
  fstring-contents|1:
    - match: '\}'
      scope: punctuation.brace.fstring-expr-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: fstring-literal
  fstring-literal|0:
    - meta_include_prototype: false
    - match: '\\\{|\\\}|\\\\|\\n|\\t|\\b|\\"|\\'''
      scope: constant.character.escape.sap
    - match: '\\x[[:xdigit:]]{2}'
      scope: constant.character.escape.sap
    - match: '\\u[[:xdigit:]]{4}'
      scope: constant.character.escape.sap
    - match: '\\U[[:xdigit:]]{8}'
      scope: constant.character.escape.sap
    - match: '\{'
      scope: punctuation.brace.fstring-expr-start.sap
      push: fstring-contents|0
    - match: '[^"]'
      scope: string.quoted.double.sap
    - match: '(")'
      captures:
        1: punctuation.quote.fstring-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.function.sap
      push: func-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|1:
    - match: '\['
      scope: punctuation.paren.generic-params-start.sap
      push: func-defn|2
      pop: true
    - match: '\('
      scope: punctuation.paren.params-start.sap
      push: func-defn|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|10:
    - match: '[A-Za-z_][[:word:]]*'
      scope: support.type.generic.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|11:
    - match: '\('
      scope: punctuation.paren.params-start.sap
      push: func-defn|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|2:
    - match: '[A-Za-z_][[:word:]]*'
      scope: support.type.generic.sap
      push: func-defn|9
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|3:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: [func-defn|4, parameter-list|0]
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: variable.parameter.sap
      push: [func-defn|4, parameter-list|1]
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      push: [func-defn|4, parameter-list|2]
      pop: true
    - match: '\)'
      scope: punctuation.paren.params-end.sap
      push: func-defn|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|4:
    - match: '\)'
      scope: punctuation.paren.params-end.sap
      push: func-defn|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|5:
    - match: '->'
      scope: punctuation.arrow.sap
      push: func-defn|6
      pop: true
    - match: '\{'
      scope: punctuation.brace.sap
      push: func-defn|7
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|6:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: func-defn|8
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: func-defn|8
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [func-defn|8, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [func-defn|8, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: func-defn|8
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [func-defn|8, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [func-defn|8, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|7:
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
      push: block-stmt|0
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: ';'
      scope: punctuation.terminator.sap
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|8:
    - match: '\{'
      scope: punctuation.brace.sap
      push: func-defn|7
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: func-defn
  func-defn|9:
    - match: ','
      scope: punctuation.comma.sap
      push: func-defn|10
    - match: '\]'
      scope: punctuation.paren.generic-params-end.sap
      push: func-defn|11
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|0:
    - match: '\.'
      scope: punctuation.period.sap
      push: if-let-binding|1
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: if-let-binding|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|1:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variant-name.sap
      push: if-let-binding|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|2:
    - match: '\('
      scope: punctuation.lparen.sap
      push: if-let-binding|3
      pop: true
    - match: '='
      scope: keyword.operator.sap
      push: binop-expr|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|3:
    - match: '&'
      scope: keyword.operator.sap
      push: if-let-binding|4
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: if-let-binding|5
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: if-let-binding|6
    - match: '\)'
      scope: punctuation.rparen.sap
      push: if-let-binding|7
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|4:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: if-let-binding|5
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: if-let-binding|6
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|5:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: if-let-binding|6
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|6:
    - match: ':'
      scope: punctuation.colon.sap
      push: if-let-binding|8
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: if-let-binding
  if-let-binding|7:
    - match: '='
      scope: keyword.operator.sap
      push: binop-expr|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|8:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: if-let-binding|9
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-let-binding
  if-let-binding|9:
    - match: ','
      scope: punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: if-stmt
  if-stmt|0:
    - meta_content_scope: meta.control-flow.if-stmt.sap
    - match: '\('
      scope: punctuation.paren.if-start.sap
      push: if-stmt|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-stmt
  if-stmt|1:
    - meta_content_scope: meta.control-flow.if-stmt.sap
    - match: 'var'
      scope: storage.type.sap
      push: [if-stmt|2|entry-0, if-let-binding|0]
      pop: true
    - match: 'let'
      scope: storage.type.sap
      push: [if-stmt|2|entry-0, if-let-binding|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [if-stmt|2|entry-0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: if-stmt
  if-stmt|2:
    - meta_content_scope: meta.control-flow.if-stmt.sap
    - match: '\)'
      scope: punctuation.paren.if-end.sap
      push: [if-stmt|meta, block-stmt|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  if-stmt|2|entry-0:
    - match: ''
      set: if-stmt|2
  # Meta scope context for if-stmt
  if-stmt|meta:
    - meta_content_scope: meta.control-flow.if-stmt.sap
    - match: ''
      pop: true
  # Rule: import-stmt
  import-stmt|0:
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [import-stmt|1, string-literal|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: import-stmt
  import-stmt|1:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Include context for branch point document-start@1
  include!document-start@1:
    - match: '(?=,)'
      branch_point: document-start@1
      branch:
        - document-start|4|document-start@1
        - document-start|6|document-start@1
  # Rule: main
  main:
    - match: '(/#)'
      scope: meta.script.preamble.sap comment.block.sap punctuation.definition.comment.sap
      push: [main|0, preamble|0|entry-0, block-comment|0]
      pop: true
    - match: '(#+).*\n?'
      scope: meta.script.preamble.sap comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
      push: [main|0, preamble|meta, preamble|0]
      pop: true
    - match: 'fn'
      scope: meta.script.preamble.sap storage.type.sap
      push: [main|0, preamble|0|entry-0, func-defn|0]
      pop: true
    - match: '(global\s+)?(var|let)'
      scope: meta.script.preamble.sap
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: [main|0, preamble|0|entry-0, var-defn|0]
      pop: true
    - match: 'struct'
      scope: meta.script.preamble.sap storage.type.sap
      push: [main|0, preamble|0|entry-0, struct-defn|0]
      pop: true
    - match: 'enum'
      scope: meta.script.preamble.sap storage.type.sap
      push: [main|0, preamble|0|entry-0, enum-defn|0]
      pop: true
    - match: 'union'
      scope: meta.script.preamble.sap storage.type.sap
      push: [main|0, preamble|0|entry-0, union-defn|0]
      pop: true
    - match: 'return'
      scope: meta.script.preamble.sap keyword.return.sap
      push: [main|0, preamble|0|entry-0, return-stmt|0]
      pop: true
    - match: 'if'
      scope: meta.script.preamble.sap meta.control-flow.if-stmt.sap keyword.if.sap
      push: [main|0, preamble|0|entry-0, if-stmt|0]
      pop: true
    - match: 'else'
      scope: meta.script.preamble.sap meta.control-flow.else-stmt.sap keyword.else.sap
      push: [main|0, preamble|0|entry-0, else-stmt|meta, block-stmt|0]
      pop: true
    - match: 'break'
      scope: meta.script.preamble.sap keyword.break.sap
      push: [main|0, preamble|0|entry-0, break-stmt|0]
      pop: true
    - match: 'continue'
      scope: meta.script.preamble.sap keyword.continue.sap
      push: [main|0, preamble|0|entry-0, continue-stmt|0]
      pop: true
    - match: 'import'
      scope: meta.script.preamble.sap keyword.import.sap
      push: [main|0, preamble|0|entry-0, import-stmt|0]
      pop: true
    - match: 'using'
      scope: meta.script.preamble.sap keyword.using.sap
      push: [main|0, preamble|0|entry-0, using-stmt|0]
      pop: true
    - match: 'namespace'
      scope: meta.script.preamble.sap meta.namespace-defn.sap keyword.sap
      push: [main|0, preamble|0|entry-0, namespace-defn|0]
      pop: true
    - match: 'while'
      scope: meta.script.preamble.sap keyword.while.sap
      push: [main|0, preamble|0|entry-0, while-loop|0]
      pop: true
    - match: 'for'
      scope: meta.script.preamble.sap keyword.for.sap
      push: [main|0, preamble|0|entry-0, for-loop|0]
      pop: true
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      scope: meta.script.preamble.sap
      captures:
        1: storage.modifier.sap
      push: [main|0, preamble|0|entry-0, block-stmt|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: meta.script.preamble.sap constant.numeric.length.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: meta.script.preamble.sap constant.numeric.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: meta.script.preamble.sap constant.language.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: meta.script.preamble.sap string.quoted.double.sap punctuation.quote.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      scope: meta.script.preamble.sap
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: meta.script.preamble.sap punctuation.bracket.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: meta.script.preamble.sap punctuation.period.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      scope: meta.script.preamble.sap
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      scope: meta.script.preamble.sap
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: meta.script.preamble.sap string.quoted.single.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: meta.script.preamble.sap keyword.operator.cast.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: meta.script.preamble.sap punctuation.brace.struct-start.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      scope: meta.script.preamble.sap
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: meta.script.preamble.sap support.type.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: meta.script.preamble.sap punctuation.paren.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: meta.script.preamble.sap keyword.operator.ellipsis.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: meta.script.preamble.sap keyword.operator.move.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: meta.script.preamble.sap keyword.operator.addr.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: meta.script.preamble.sap keyword.operator.plus.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: meta.script.preamble.sap keyword.operator.minus.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: meta.script.preamble.sap keyword.operator.not.sap
      push: [main|0, preamble|0|entry-0, stmt|0, binop-expr2|0, unary-expr|0]
      pop: true
    - match: ';'
      scope: meta.script.preamble.sap punctuation.terminator.sap
      push: [main|0, preamble|0]
      pop: true
    - match: '\\start_document'
      scope: meta.script.preamble.sap keyword.sap
      push: [main|0, preamble|meta, document-start|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: main
  main|0:
    - match: '(\\)(#)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\\)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\{)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\})'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(;)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '\{'
      scope: meta.para.sap keyword.brace.sap
      push: paragraph|0
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(\{)'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.brace.sap
      push: [paragraph|meta, script-block|0]
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(::)?'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.scope.sap
      push: [paragraph|meta, script-block|1]
    - match: '\\'
      scope: meta.para.sap meta.script.inline-call.sap punctuation.misc.sap
      push: [paragraph|meta, script-call|0]
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '.*?'
      scope: meta.para.sap meta.para.text.sap
  # Rule: namespace-defn
  namespace-defn|0:
    - meta_content_scope: meta.namespace-defn.sap
    - match: '([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))?'
      captures:
        1: meta.name.scope-part.sap
        2: punctuation.scope.sap
        3: meta.name.scope-part.sap
      push: namespace-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: namespace-defn
  namespace-defn|1:
    - meta_content_scope: meta.namespace-defn.sap
    - match: '\{'
      scope: punctuation.brace.sap
      push: namespace-defn|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: namespace-defn
  namespace-defn|2:
    - meta_content_scope: meta.namespace-defn.sap
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
      push: block-stmt|0
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: ';'
      scope: punctuation.terminator.sap
    - match: '\}'
      scope: meta.namespace-defn.sap punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: paragraph
  paragraph|0:
    - meta_content_scope: meta.para.sap
    - match: '(\\)(#)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\\)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\{)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\})'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(;)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '\{'
      scope: meta.para.sap keyword.brace.sap
      push: paragraph|0
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(\{)'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.brace.sap
      push: [paragraph|meta, script-block|0]
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(::)?'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.scope.sap
      push: [paragraph|meta, script-block|1]
    - match: '\\'
      scope: meta.para.sap meta.script.inline-call.sap punctuation.misc.sap
      push: [paragraph|meta, script-call|0]
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '.*?'
      scope: meta.para.sap meta.para.text.sap
    - match: '\}'
      scope: meta.para.sap keyword.brace.sap
      pop: true
    - match: '(?=\S)'
      push: paragraph|1
      pop: true
  # Rule: paragraph
  paragraph|1:
    - meta_content_scope: meta.para.sap
    - match: '(\\)(#)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\\)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\{)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\})'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(;)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '\{'
      scope: meta.para.sap keyword.brace.sap
      push: [paragraph|2, paragraph|0]
      pop: true
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(\{)'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.brace.sap
      push: [paragraph|2, paragraph|meta, script-block|0]
      pop: true
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(::)?'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.scope.sap
      push: [paragraph|2, paragraph|meta, script-block|1]
      pop: true
    - match: '\\'
      scope: meta.para.sap meta.script.inline-call.sap punctuation.misc.sap
      push: [paragraph|2, paragraph|meta, script-call|0]
      pop: true
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      push: [paragraph|2, paragraph|3]
      pop: true
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      push: [paragraph|2, paragraph|4]
      pop: true
    - match: '.*?'
      scope: meta.para.sap meta.para.text.sap
      push: paragraph|2
      pop: true
  # Rule: paragraph
  paragraph|2:
    - match: '(\\)(#)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\\)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\{)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(\})'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '(\\)(;)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
    - match: '\{'
      scope: meta.para.sap keyword.brace.sap
      push: paragraph|0
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(\{)'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.brace.sap
      push: [paragraph|meta, script-block|0]
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(::)?'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.scope.sap
      push: [paragraph|meta, script-block|1]
    - match: '\\'
      scope: meta.para.sap meta.script.inline-call.sap punctuation.misc.sap
      push: [paragraph|meta, script-call|0]
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '.*?'
      scope: meta.para.sap meta.para.text.sap
    - match: '\}'
      scope: keyword.brace.sap
      pop: true
    - match: '(?=\S)'
      push: paragraph|5
      pop: true
  paragraph|3:
    - match: ''
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
      pop: true
  paragraph|4:
    - match: ''
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
      pop: true
  # Rule: paragraph
  paragraph|5:
    - match: '(\\)(#)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\\)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\{)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(\})'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '(\\)(;)'
      scope: meta.para.sap
      captures:
        1: punctuation.escape.sap
      push: paragraph|2
      pop: true
    - match: '\{'
      scope: meta.para.sap keyword.brace.sap
      push: [paragraph|2, paragraph|0]
      pop: true
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(\{)'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.brace.sap
      push: [paragraph|2, paragraph|meta, script-block|0]
      pop: true
    - match: '(\\script)\s*(@\s*(layout|position|post|finalise|render))?\s*(::)?'
      scope: meta.para.sap meta.script.block.sap
      captures:
        1: keyword.block.script.sap
        2: storage.modifier.sap
        4: punctuation.scope.sap
      push: [paragraph|2, paragraph|meta, script-block|1]
      pop: true
    - match: '\\'
      scope: meta.para.sap meta.script.inline-call.sap punctuation.misc.sap
      push: [paragraph|2, paragraph|meta, script-call|0]
      pop: true
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      push: [paragraph|2, paragraph|6]
      pop: true
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      scope: meta.para.sap
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      push: [paragraph|2, paragraph|7]
      pop: true
    - match: '.*?'
      scope: meta.para.sap meta.para.text.sap
      push: paragraph|2
      pop: true
  paragraph|6:
    - match: ''
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
      pop: true
  paragraph|7:
    - match: ''
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
      pop: true
  # Meta scope context for paragraph
  paragraph|meta:
    - meta_content_scope: meta.para.sap
    - match: ''
      pop: true
  # Rule: parameter-list
  parameter-list|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: variable.parameter.sap
      push: parameter-list|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|1:
    - match: ':'
      scope: punctuation.colon.sap
      push: parameter-list|7
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|10:
    - match: ','
      scope: punctuation.comma.sap
      push: parameter-list|2
    - match: '(?=\S)'
      pop: true
  # Rule: parameter-list
  parameter-list|11:
    - match: ','
      scope: punctuation.comma.sap
      push: parameter-list|2
    - match: '(?=\S)'
      pop: true
  # Rule: parameter-list
  parameter-list|2:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: parameter-list|3
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: variable.parameter.sap
      push: parameter-list|4
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|3:
    - match: '[A-Za-z_][[:word:]]*'
      scope: variable.parameter.sap
      push: parameter-list|4
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|4:
    - match: ':'
      scope: punctuation.colon.sap
      push: parameter-list|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|5:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: parameter-list|6
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: parameter-list|6
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [parameter-list|6, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [parameter-list|6, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: parameter-list|6
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [parameter-list|6, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [parameter-list|6, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|6:
    - match: '='
      scope: punctuation.equal.sap
      push: binop-expr|0
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: parameter-list
  parameter-list|7:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: parameter-list|8
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: parameter-list|8
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [parameter-list|8, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [parameter-list|8, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: parameter-list|8
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [parameter-list|8, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [parameter-list|8, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: parameter-list
  parameter-list|8:
    - match: '='
      scope: punctuation.equal.sap
      push: parameter-list|9
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      push: [parameter-list|10, parameter-list|2]
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: parameter-list
  parameter-list|9:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [parameter-list|11, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [parameter-list|11, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|0:
    - match: '([A-Za-z_][[:word:]]*)\s*(:)\s*(?!:)'
      captures:
        1: variable.parameter.sap
        2: punctuation.colon.sap
      push: [postfix-expr2|9, binop-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [postfix-expr2|9, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [postfix-expr2|9, binop-expr2|0, unary-expr|0]
    - match: '\)'
      scope: punctuation.paren.call-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|1:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [postfix-expr2|5, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [postfix-expr2|5, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|2:
    - match: '[A-Za-z_][A-Za-z0-9_]*'
      scope: meta.name.struct.field.sap
      push: [postfix-expr2|4, struct-literal-field-list|0, struct-literal-field|0]
      pop: true
    - match: '\}'
      scope: punctuation.brace.struct-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|3:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.field.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|4:
    - match: '\}'
      scope: punctuation.brace.struct-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|5:
    - match: ':'
      scope: punctuation.colon.slice.sap
      push: postfix-expr2|6
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      push: [postfix-expr2|7, binop-expr|0]
      pop: true
    - match: '\]'
      scope: punctuation.bracket.subscript-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|6:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [postfix-expr2|8, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [postfix-expr2|8, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|7:
    - match: ','
      scope: punctuation.comma.sap
      push: binop-expr|0
    - match: '\]'
      scope: punctuation.bracket.subscript-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|8:
    - match: '\]'
      scope: punctuation.bracket.subscript-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr2
  postfix-expr2|9:
    - match: ','
      scope: punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: postfix-expr
  postfix-expr|0:
    - match: '\s*'
      push: postfix-expr|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: postfix-expr
  postfix-expr|1:
    - match: '\('
      scope: punctuation.paren.call-start.sap
      push: postfix-expr2|0
    - match: '\['
      scope: punctuation.bracket.subscript-start.sap
      push: postfix-expr2|1
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: postfix-expr2|2
    - match: '!'
      scope: keyword.operator.deref.sap
    - match: '\?(?!\?)'
      scope: keyword.operator.qn.sap
    - match: '\.'
      scope: punctuation.operator.dot.sap
      push: postfix-expr2|3
    - match: '(?=\S)'
      pop: true
  # Rule: preamble
  preamble|0:
    - meta_content_scope: meta.script.preamble.sap
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
      push: block-stmt|0
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: ';'
      scope: punctuation.terminator.sap
    - match: '\\start_document'
      scope: keyword.sap
      push: [preamble|meta, document-start|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  preamble|0|entry-0:
    - match: ''
      set: preamble|0
  # Meta scope context for preamble
  preamble|meta:
    - meta_content_scope: meta.script.preamble.sap
    - match: ''
      pop: true
  # Rule: primary-expr
  primary-expr|0:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [primary-expr|1, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [primary-expr|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: primary-expr
  primary-expr|1:
    - match: '\)'
      scope: punctuation.paren.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: prototype
  prototype:
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
  # Rule: return-stmt
  return-stmt|0:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [return-stmt|1, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [return-stmt|1, binop-expr2|0, unary-expr|0]
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: return-stmt
  return-stmt|1:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-block
  script-block|0:
    - meta_content_scope: meta.script.block.sap
    - match: '(/#)'
      scope: comment.block.sap punctuation.definition.comment.sap
      push: block-comment|0
    - match: '(#+).*\n?'
      scope: comment.line.sap
      captures:
        1: punctuation.definition.comment.sap
    - match: 'fn'
      scope: storage.type.sap
      push: func-defn|0
    - match: '(global\s+)?(var|let)'
      captures:
        1: storage.modifier.sap
        2: storage.type.sap
      push: var-defn|0
    - match: 'struct'
      scope: storage.type.sap
      push: struct-defn|0
    - match: 'enum'
      scope: storage.type.sap
      push: enum-defn|0
    - match: 'union'
      scope: storage.type.sap
      push: union-defn|0
    - match: 'return'
      scope: keyword.return.sap
      push: return-stmt|0
    - match: 'if'
      scope: meta.control-flow.if-stmt.sap keyword.if.sap
      push: if-stmt|0
    - match: 'else'
      scope: meta.control-flow.else-stmt.sap keyword.else.sap
      push: [else-stmt|meta, block-stmt|0]
    - match: 'break'
      scope: keyword.break.sap
      push: break-stmt|0
    - match: 'continue'
      scope: keyword.continue.sap
      push: continue-stmt|0
    - match: 'import'
      scope: keyword.import.sap
      push: import-stmt|0
    - match: 'using'
      scope: keyword.using.sap
      push: using-stmt|0
    - match: 'namespace'
      scope: meta.namespace-defn.sap keyword.sap
      push: namespace-defn|0
    - match: 'while'
      scope: keyword.while.sap
      push: while-loop|0
    - match: 'for'
      scope: keyword.for.sap
      push: for-loop|0
    - match: '(@\s*(?:layout|position|post|finalise|render))(?=\s+|\{)'
      captures:
        1: storage.modifier.sap
      push: block-stmt|0
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [stmt|0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [stmt|0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [stmt|0, binop-expr2|0, unary-expr|0]
    - match: ';'
      scope: punctuation.terminator.sap
    - match: '\}'
      scope: meta.script.block.sap punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-block
  script-block|1:
    - meta_content_scope: meta.script.block.sap
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.namespace.sap
      push: script-block|2
    - match: '\s*(\{)'
      captures:
        1: punctuation.brace.sap
      push: script-block|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-block
  script-block|2:
    - match: '(::)'
      scope: punctuation.scope.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call-tail
  script-call-tail|0:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: script-call
  script-call|0:
    - meta_content_scope: meta.script.inline-call.sap
    - match: '::'
      scope: punctuation.scope.sap
      push: script-call|1
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: support.function.sap
      push: script-call|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|1:
    - meta_content_scope: meta.script.inline-call.sap
    - match: '[A-Za-z_][[:word:]]*'
      scope: support.function.sap
      push: script-call|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|2:
    - meta_content_scope: meta.script.inline-call.sap
    - match: '::'
      scope: punctuation.scope.sap
      push: script-call|3
    - match: '(@\s*(layout|position|post|finalise|render))'
      scope: storage.modifier.sap
      push: script-call|4
      pop: true
    - match: '\('
      scope: punctuation.paren.call-start.sap
      push: script-call|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|3:
    - match: '[A-Za-z_][[:word:]]*'
      scope: support.function.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|4:
    - meta_content_scope: meta.script.inline-call.sap
    - match: '\('
      scope: punctuation.paren.call-start.sap
      push: script-call|5
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|5:
    - meta_content_scope: meta.script.inline-call.sap
    - match: '([A-Za-z_][[:word:]]*)\s*(:)\s*(?!:)'
      captures:
        1: variable.parameter.sap
        2: punctuation.colon.sap
      push: [script-call|6|entry-0, binop-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0]
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0]
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0]
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, string-literal|0]
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, fstring-literal|0]
    - match: '\['
      scope: punctuation.bracket.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, array-literal|0]
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, enum-literal|0]
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, text-literal|0]
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0]
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, cast-expr|0]
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, struct-literal|0]
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0]
    - match: '\$'
      scope: support.type.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, type|0]
    - match: '\('
      scope: punctuation.paren.sap
      push: [script-call|6|entry-0, binop-expr2|0, postfix-expr|0, primary-expr|0]
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|0]
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|0]
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|1]
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|0]
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|0]
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [script-call|6|entry-0, binop-expr2|0, unary-expr|0]
    - match: '\)'
      scope: punctuation.paren.call-end.sap
      push: [script-call|meta, script-call-tail|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: script-call
  script-call|6:
    - meta_content_scope: meta.script.inline-call.sap
    - match: ','
      scope: meta.script.inline-call.sap punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  script-call|6|entry-0:
    - match: ''
      set: script-call|6
  # Meta scope context for script-call
  script-call|meta:
    - meta_content_scope: meta.script.inline-call.sap
    - match: ''
      pop: true
  # Rule: stmt
  stmt|0:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: string-literal
  string-literal|0:
    - meta_content_scope: string.quoted.double.sap
    - meta_include_prototype: false
    - match: '\\\{|\\\}|\\\\|\\n|\\t|\\b|\\"|\\'''
      scope: constant.character.escape.sap
    - match: '\\x[[:xdigit:]]{2}'
      scope: constant.character.escape.sap
    - match: '\\u[[:xdigit:]]{4}'
      scope: constant.character.escape.sap
    - match: '\\U[[:xdigit:]]{8}'
      scope: constant.character.escape.sap
    - match: '[^"]'
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-defn
  struct-defn|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.struct.sap
      push: struct-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-defn
  struct-defn|1:
    - match: '\{'
      scope: punctuation.brace.sap
      push: struct-defn|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-defn
  struct-defn|2:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.struct-field.sap
      push: struct-field-defn|0
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-field-defn
  struct-field-defn|0:
    - match: ':'
      scope: punctuation.colon.sap
      push: struct-field-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-field-defn
  struct-field-defn|1:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: struct-field-defn|2
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: struct-field-defn|2
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [struct-field-defn|2, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [struct-field-defn|2, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: struct-field-defn|2
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [struct-field-defn|2, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [struct-field-defn|2, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-field-defn
  struct-field-defn|2:
    - match: '='
      scope: keyword.operator.sap
      push: struct-field-defn|3
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-field-defn
  struct-field-defn|3:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [struct-field-defn|4, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [struct-field-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-field-defn
  struct-field-defn|4:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-literal-field-list
  struct-literal-field-list|0:
    - match: ','
      scope: punctuation.comma.sap
      push: struct-literal-field-list|1
      pop: true
    - match: '[A-Za-z_][A-Za-z0-9_]*'
      scope: meta.name.struct.field.sap
      push: [struct-literal-field-list|3, struct-literal-field-list|2, struct-literal-field|0]
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: struct-literal-field-list
  struct-literal-field-list|1:
    - match: '[A-Za-z_][A-Za-z0-9_]*'
      scope: meta.name.struct.field.sap
      push: [struct-literal-field-list|2, struct-literal-field|0]
    - match: '(?=\S)'
      pop: true
  # Rule: struct-literal-field-list
  struct-literal-field-list|2:
    - match: ','
      scope: punctuation.comma.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: struct-literal-field-list
  struct-literal-field-list|3:
    - match: '[A-Za-z_][A-Za-z0-9_]*'
      scope: meta.name.struct.field.sap
      push: [struct-literal-field-list|2, struct-literal-field|0]
    - match: '(?=\S)'
      pop: true
  # Rule: struct-literal-field
  struct-literal-field|0:
    - match: ':'
      scope: punctuation.colon.sap
      push: binop-expr|0
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: struct-literal
  struct-literal|0:
    - match: '[A-Za-z_][A-Za-z0-9_]*'
      scope: meta.name.struct.field.sap
      push: [struct-literal|1, struct-literal-field-list|0, struct-literal-field|0]
      pop: true
    - match: '\}'
      scope: punctuation.brace.struct-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: struct-literal
  struct-literal|1:
    - match: '\}'
      scope: punctuation.brace.struct-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: text-literal
  text-literal|0:
    - match: '\\'
      scope: meta.script.inline-call.sap punctuation.misc.sap
      push: script-call|0
    - match: '(`{3,})(c)?(?!(\s+)([^`]*))?$\n?'
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '(`{3,})(cpp)?(?!(\s+)([^`]*))?$\n?'
      captures:
        1: punctuation.other.sap
        2: constant.other.sap
      embed: scope:source.c++
      escape: '(\1)'
      escape_captures:
        1: punctuation.other.sap
    - match: '[^}]'
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
    - match: '(?=\S)'
      push: text-literal|1
      pop: true
  # Rule: text-literal
  text-literal|1:
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
  # Rule: type
  type|0:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
    - match: '&'
      scope: keyword.operator.type.sap
      push: type|1
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: type|2
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: type|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|1:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: type|0
      pop: true
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: type|0
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: type|2
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: type|3
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|2:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: type|6
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: type|6
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [type|6, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [type|6, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: type|6
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [type|6, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [type|6, type|3]
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      push: [type|7, type|0]
      pop: true
    - match: '\)'
      scope: punctuation.paren.fn-type-start.sap
      push: type|8
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|3:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: type|4
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: type|4
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [type|4, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [type|4, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: type|4
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [type|4, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [type|4, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|4:
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: type|5
      pop: true
    - match: '\]'
      scope: punctuation.bracket.array-type-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|5:
    - match: '\]'
      scope: punctuation.bracket.array-type-end.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|6:
    - match: ','
      scope: punctuation.comma.sap
      push: type|0
    - match: '\)'
      scope: punctuation.paren.fn-type-start.sap
      push: type|8
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|7:
    - match: ','
      scope: punctuation.comma.sap
      push: type|0
    - match: '\)'
      scope: punctuation.paren.fn-type-start.sap
      push: type|9
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|8:
    - match: '->'
      scope: punctuation.arrow.sap
      push: type|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: type
  type|9:
    - match: '->'
      scope: punctuation.arrow.sap
      push: type|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: unary-expr
  unary-expr|0:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: postfix-expr|0
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: postfix-expr|0
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: postfix-expr|0
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: postfix-expr|0
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: postfix-expr|0
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
    - match: '\*'
      scope: keyword.operator.move.sap
    - match: '&'
      scope: keyword.operator.addr.sap
      push: unary-expr|1
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
    - match: '-'
      scope: keyword.operator.minus.sap
    - match: 'not'
      scope: keyword.operator.not.sap
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: unary-expr
  unary-expr|1:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: unary-expr|0
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: postfix-expr|0
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: postfix-expr|0
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: postfix-expr|0
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: postfix-expr|0
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: postfix-expr|0
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: unary-expr|0
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: unary-expr|0
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: unary-expr|0
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: unary-expr|0
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: unary-expr|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-case-defn
  union-case-defn|0:
    - match: '\('
      scope: punctuation.paren.union-case.sap
      push: union-case-defn|1
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: union-case-defn
  union-case-defn|1:
    - match: 'mut'
      scope: storage.modifier.mut.sap
      push: [union-case-defn|2, parameter-list|0]
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: variable.parameter.sap
      push: [union-case-defn|2, parameter-list|1]
      pop: true
    - match: ','
      scope: punctuation.comma.sap
      push: [union-case-defn|2, parameter-list|2]
      pop: true
    - match: '\)'
      scope: punctuation.paren.union-case.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-case-defn
  union-case-defn|2:
    - match: '\)'
      scope: punctuation.paren.union-case.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-defn
  union-defn|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.union.sap
      push: union-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-defn
  union-defn|1:
    - match: '\{'
      scope: punctuation.brace.sap
      push: union-defn|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-defn
  union-defn|2:
    - match: '[A-Za-z_][[:word:]]*'
      scope: entity.name.union-case.sap
      push: [union-defn|3, union-case-defn|0]
    - match: '\}'
      scope: punctuation.brace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: union-defn
  union-defn|3:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '(?=\S)'
      pop: true
  # Rule: using-stmt
  using-stmt|0:
    - match: '::'
      scope: punctuation.scope.sap
      push: using-stmt|1
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.namespace.sap
      push: using-stmt|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|1:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.namespace.sap
      push: using-stmt|2
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|2:
    - match: '::'
      scope: punctuation.scope.sap
      push: using-stmt|3
    - match: '='
      scope: punctuation.equal.sap
      push: using-stmt|4
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|3:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.namespace.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|4:
    - match: '::'
      scope: punctuation.scope.sap
      push: using-stmt|5
      pop: true
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.namespace.sap
      push: using-stmt|6
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|5:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.namespace.sap
      push: using-stmt|6
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: using-stmt
  using-stmt|6:
    - match: '::'
      scope: punctuation.scope.sap
      push: using-stmt|3
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|0:
    - match: '[A-Za-z_][[:word:]]*'
      scope: meta.name.variable.sap
      push: var-defn|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|1:
    - match: ':'
      scope: punctuation.colon.sap
      push: var-defn|2
      pop: true
    - match: '='
      scope: keyword.operator.sap
      push: var-defn|3
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|2:
    - match: '\b(any|int|bool|char|void|float|string|Inline(Ref)?|Block(Ref)?|LayoutObject(Ref)?|Length)\b'
      scope: support.type.builtin.sap
      push: var-defn|5
      pop: true
    - match: '(builtin::)?PagePosition|AbsPosition|Colour|ColourRGB|ColourCMYK|Size2d|Pos2d'
      scope: support.type.builtin.sap
      push: var-defn|5
      pop: true
    - match: '\?'
      scope: keyword.operator.type.sap
      push: [var-defn|5, type|0]
      pop: true
    - match: '&'
      scope: keyword.operator.type.sap
      push: [var-defn|5, type|1]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: var-defn|5
      pop: true
    - match: '\('
      scope: punctuation.paren.fn-type-start.sap
      push: [var-defn|5, type|2]
      pop: true
    - match: '\['
      scope: punctuation.bracket.array-type-start.sap
      push: [var-defn|5, type|3]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|3:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [var-defn|4, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [var-defn|4, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|4:
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: var-defn
  var-defn|5:
    - match: '='
      scope: keyword.operator.sap
      push: var-defn|3
      pop: true
    - match: ';'
      scope: punctuation.terminator.sap
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: while-loop
  while-loop|0:
    - match: '\('
      scope: punctuation.paren.while-start.sap
      push: while-loop|1
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: while-loop
  while-loop|1:
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)(\s*(ex|em|rem|mm|cm|in|pt|pc))\b'
      scope: constant.numeric.length.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b([[:digit:]]+(\.([[:digit:]]+))?)\b'
      scope: constant.numeric.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\b(true|false|null)\b'
      scope: constant.language.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '"'
      scope: string.quoted.double.sap punctuation.quote.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, string-literal|0]
      pop: true
    - match: '(f)(")'
      captures:
        1: storage.type.string.sap
        2: punctuation.quote.fstring-start.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, fstring-literal|0]
      pop: true
    - match: '\['
      scope: punctuation.bracket.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, array-literal|0]
      pop: true
    - match: '\.(?!\.)'
      scope: punctuation.period.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, enum-literal|0]
      pop: true
    - match: '(\\(box|vbox|hbox|zbox|line|para))\s*(\{)'
      captures:
        1: keyword.block.text.sap
        3: punctuation.brace.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '(\\)\s*(\{)'
      captures:
        1: keyword.inline.text.sap
        2: punctuation.brace.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, text-literal|0]
      pop: true
    - match: '''.*?'''
      scope: string.quoted.single.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: 'cast'
      scope: keyword.operator.cast.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, cast-expr|0]
      pop: true
    - match: '\{'
      scope: punctuation.brace.struct-start.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, struct-literal|0]
      pop: true
    - match: '(::)?(?!not)([A-Za-z_][[:word:]]*)(?:\s*(::)\s*([A-Za-z_][[:word:]]*))*'
      captures:
        1: punctuation.scope.sap
        2: variable.other.sap
        3: punctuation.scope.sap
        4: variable.other.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0]
      pop: true
    - match: '\$'
      scope: support.type.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, type|0]
      pop: true
    - match: '\('
      scope: punctuation.paren.sap
      push: [while-loop|2, binop-expr2|0, postfix-expr|0, primary-expr|0]
      pop: true
    - match: '\.\.\.'
      scope: keyword.operator.ellipsis.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\*'
      scope: keyword.operator.move.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '&'
      scope: keyword.operator.addr.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|1]
      pop: true
    - match: '\+'
      scope: keyword.operator.plus.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '-'
      scope: keyword.operator.minus.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: 'not'
      scope: keyword.operator.not.sap
      push: [while-loop|2, binop-expr2|0, unary-expr|0]
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
  # Rule: while-loop
  while-loop|2:
    - match: '\)'
      scope: punctuation.paren.while-end.sap
      push: block-stmt|0
      pop: true
    - match: '\S'
      scope: invalid.illegal.sap
      pop: true
